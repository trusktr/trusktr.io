var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _fixBabelExtend = function (O) {
  var gPO = O.getPrototypeOf || function (o) {
    return o.__proto__;
  },
      sPO = O.setPrototypeOf || function (o, p) {
    o.__proto__ = p;
    return o;
  },
      construct = (typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' ? Reflect.construct : function (Parent, args, Class) {
    var Constructor,
        a = [null];
    a.push.apply(a, args);
    Constructor = Parent.bind.apply(Parent, a);
    return sPO(new Constructor(), Class.prototype);
  };

  return function fixBabelExtend(Class) {
    var Parent = gPO(Class);
    return sPO(Class, sPO(function Super() {
      return construct(Parent, arguments, gPO(this).constructor);
    }, Parent));
  };
}(Object);

import { dashCase, empty, keys } from './util.js';

export function normalizeAttributeDefinition(name, prop) {
  var attribute = prop.attribute;

  var obj = (typeof attribute === 'undefined' ? 'undefined' : _typeof(attribute)) === 'object' ? _extends({}, attribute) : {
    source: attribute,
    target: attribute
  };
  if (obj.source === true) {
    obj.source = dashCase(name);
  }
  if (obj.target === true) {
    obj.target = dashCase(name);
  }
  return obj;
}

function identity(v) {
  return v;
}

export function normalizePropertyDefinition(name, prop) {
  var coerce = prop.coerce,
      def = prop.default,
      deserialize = prop.deserialize,
      serialize = prop.serialize;

  return {
    attribute: normalizeAttributeDefinition(name, prop),
    coerce: coerce || identity,
    default: typeof def === 'function' ? def : function () {
      return def;
    },
    deserialize: deserialize || identity,
    serialize: serialize || identity
  };
}

var defaultTypesMap = new Map();

function defineProps(constructor, WithUpdate) {
  if (constructor.hasOwnProperty('_propsNormalized')) return;
  var props = constructor.props;

  constructor._propsList = [];
  keys(props).forEach(function (name) {
    var func = props[name] || props.any;
    if (defaultTypesMap.has(func)) func = defaultTypesMap.get(func);
    if (typeof func !== 'function') func = prop(func);
    func({ constructor: constructor }, name, WithUpdate);
    constructor._propsList.push(name);
  });
}

function delay(fn) {
  if (window.Promise) {
    Promise.resolve().then(fn);
  } else {
    setTimeout(fn);
  }
}

export function prop(definition) {
  var propertyDefinition = definition || {};

  // Allows decorators, or imperative definitions.
  var func = function func(_ref, name, WithUpdate) {
    var constructor = _ref.constructor;

    var normalized = normalizePropertyDefinition(name, propertyDefinition);

    // Ensure that we can cache properties. We have to do this so the _props object literal doesn't modify parent
    // classes or share the instance anywhere where it's not intended to be shared explicitly in userland code.
    if (!constructor.hasOwnProperty('_propsNormalized')) {
      constructor._propsNormalized = {};
    }

    // Cache the value so we can reference when syncing the attribute to the property.
    constructor._propsNormalized[name] = normalized;
    var _normalized$attribute = normalized.attribute,
        source = _normalized$attribute.source,
        target = _normalized$attribute.target;


    if (source) {
      constructor._observedAttributes.push(source);
      constructor._attributeToPropertyMap[source] = name;
      if (source !== target) {
        constructor._attributeToAttributeMap[source] = target;
      }
    }

    Object.defineProperty(WithUpdate.prototype, name, {
      configurable: true,
      get: function get() {
        var val = this._props[name];
        return val == null ? this._props[name] = normalized.default.call(this, name) : val;
      },
      set: function set(val) {
        var target = normalized.attribute.target,
            serialize = normalized.serialize,
            coerce = normalized.coerce;

        if (target) {
          var serializedVal = serialize ? serialize.call(this, val, name) : val;
          if (serializedVal == null) {
            this.removeAttribute(target);
          } else {
            this.setAttribute(target, serializedVal);
          }
        }
        this._props[name] = coerce.call(this, val, name);
        this._modifiedProps[name] = true;
        this.triggerUpdate();
      }
    });
  };

  // Allows easy extension of pre-defined props { ...prop(), ...{} }.
  Object.keys(propertyDefinition).forEach(function (key) {
    return func[key] = propertyDefinition[key];
  });

  return func;
}

export var withUpdate = function withUpdate() {
  var _class, _temp2;

  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;
  return _fixBabelExtend((_temp2 = _class = function (_Base) {
    _inherits(WithUpdate, _Base);

    function WithUpdate() {
      var _ref2;

      var _temp, _this, _ret;

      _classCallCheck(this, WithUpdate);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = WithUpdate.__proto__ || Object.getPrototypeOf(WithUpdate)).call.apply(_ref2, [this].concat(args))), _this), _this._prevProps = {}, _this._prevState = {}, _this._props = {}, _this._state = {}, _this._modifiedProps = {}, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(WithUpdate, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, oldValue, newValue) {
        var _constructor = this.constructor,
            _attributeToAttributeMap = _constructor._attributeToAttributeMap,
            _attributeToPropertyMap = _constructor._attributeToPropertyMap,
            _propsNormalized = _constructor._propsNormalized;


        if (_get(WithUpdate.prototype.__proto__ || Object.getPrototypeOf(WithUpdate.prototype), 'attributeChangedCallback', this)) {
          _get(WithUpdate.prototype.__proto__ || Object.getPrototypeOf(WithUpdate.prototype), 'attributeChangedCallback', this).call(this, name, oldValue, newValue);
        }

        var propertyName = _attributeToPropertyMap[name];
        if (propertyName) {
          var propertyDefinition = _propsNormalized[propertyName];
          if (propertyDefinition) {
            var defaultValue = propertyDefinition.default,
                deserialize = propertyDefinition.deserialize;

            var propertyValue = deserialize ? deserialize.call(this, newValue, propertyName) : newValue;
            this._props[propertyName] = propertyValue == null ? defaultValue.call(this) : propertyValue;
            this._modifiedProps[propertyName] = true;
            this.triggerUpdate();
          }
        }

        var targetAttributeName = _attributeToAttributeMap[name];
        if (targetAttributeName) {
          if (newValue == null) {
            this.removeAttribute(targetAttributeName);
          } else {
            this.setAttribute(targetAttributeName, newValue);
          }
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        if (_get(WithUpdate.prototype.__proto__ || Object.getPrototypeOf(WithUpdate.prototype), 'connectedCallback', this)) {
          _get(WithUpdate.prototype.__proto__ || Object.getPrototypeOf(WithUpdate.prototype), 'connectedCallback', this).call(this);
        }
        var propsList = this.constructor._propsList;
        for (var i = 0, l = propsList.length; i < l; i += 1) {
          this._modifiedProps[propsList[i]] = true;
        }this.triggerUpdate();
      }
    }, {
      key: 'shouldUpdate',
      value: function shouldUpdate() {
        return true;
      }
    }, {
      key: 'triggerUpdate',
      value: function triggerUpdate() {
        var _this2 = this;

        if (this._updating || !this.parentNode) {
          return;
        }
        this._updating = true;
        delay(function () {
          var _prevProps = _this2._prevProps,
              _prevState = _this2._prevState,
              _modifiedProps = _this2._modifiedProps;

          if (_this2.updating) {
            _this2.updating(_prevProps, _prevState, _modifiedProps);
          }
          if (_this2.updated && _this2.shouldUpdate(_prevProps, _prevState, _modifiedProps)) {
            _this2.updated(_prevProps, _prevState, _modifiedProps);
          }
          _this2._prevProps = _this2.props;
          _this2._prevState = _this2.state;
          var propsList = _this2.constructor._propsList;
          for (var i = 0, l = propsList.length; i < l; i += 1) {
            _this2._modifiedProps[propsList[i]] = false;
          }_this2._updating = false;
        });
      }
    }, {
      key: 'props',
      get: function get() {
        var _this3 = this;

        return keys(this.constructor.props).reduce(function (prev, curr) {
          prev[curr] = _this3[curr];
          return prev;
        }, {});
      },
      set: function set(props) {
        var _this4 = this;

        var ctorProps = this.constructor.props;
        keys(props).forEach(function (k) {
          return k in ctorProps && (_this4[k] = props[k]);
        });
      }
    }, {
      key: 'state',
      get: function get() {
        return this._state;
      },
      set: function set(state) {
        this._state = state;
        this.triggerUpdate();
      }
    }], [{
      key: 'observedAttributes',
      get: function get() {
        // We have to define props here because observedAttributes are retrieved
        // only once when the custom element is defined. If we did this only in
        // the constructor, then props would not link to attributes.
        defineProps(this, WithUpdate);
        return this._observedAttributes.concat(_get(WithUpdate.__proto__ || Object.getPrototypeOf(WithUpdate), 'observedAttributes', this) || []);
      }
    }, {
      key: 'props',
      get: function get() {
        return this._props;
      },
      set: function set(props) {
        this._props = props;
      }
    }]);

    return WithUpdate;
  }(Base), _class._attributeToAttributeMap = {}, _class._attributeToPropertyMap = {}, _class._observedAttributes = [], _class._props = {}, _temp2));
};

var parse = JSON.parse,
    stringify = JSON.stringify;

var attribute = Object.freeze({ source: true });
var zeroOrNumber = function zeroOrNumber(val) {
  return empty(val) ? 0 : Number(val);
};

var any = prop({
  attribute: attribute
});

var array = prop({
  attribute: attribute,
  coerce: function coerce(val) {
    return Array.isArray(val) ? val : empty(val) ? null : [val];
  },
  default: Object.freeze([]),
  deserialize: parse,
  serialize: stringify
});

var boolean = prop({
  attribute: attribute,
  coerce: Boolean,
  default: false,
  deserialize: function deserialize(val) {
    return !empty(val);
  },
  serialize: function serialize(val) {
    return val ? '' : null;
  }
});

var number = prop({
  attribute: attribute,
  default: 0,
  coerce: zeroOrNumber,
  deserialize: zeroOrNumber,
  serialize: function serialize(val) {
    return empty(val) ? null : String(Number(val));
  }
});

var object = prop({
  attribute: attribute,
  default: Object.freeze({}),
  deserialize: parse,
  serialize: stringify
});

var string = prop({
  attribute: attribute,
  default: '',
  coerce: String,
  serialize: function serialize(val) {
    return empty(val) ? null : String(val);
  }
});

defaultTypesMap.set(Array, array);
defaultTypesMap.set(Boolean, boolean);
defaultTypesMap.set(Number, number);
defaultTypesMap.set(Object, object);
defaultTypesMap.set(String, string);

export var props = {
  any: any,
  array: array,
  boolean: boolean,
  number: number,
  object: object,
  string: string
};